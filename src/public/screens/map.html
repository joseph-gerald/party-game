<div style="
    width: 100%;
    height: 100%; 

    display: flex;
    justify-content: center;
    align-items: center;
">
    <div class="map">
        <img draggable="false" id="map-img" src="" alt="">

        <div class="players">
        </div>
    </div>
</div>

<script>
    const mapImg = document.getElementById("map-img");
    const mapElm = document.querySelector(".map")
    const map = window.room.map;
    let steps = [];

    const popup = document.getElementById("popup");
    const popupMessage = document.getElementById("popup-text");

    const playersElm = document.querySelector(".players");

    mapImg.src = map.image_url;
    window.hideText = hideText;
    window.showText = showText;

    showPopup();

    function onLoad() {
        const loadingBar = document.getElementById("game-connect-loader");

        loadingBar.style.transition = ".35s ease-out";
        loadingBar.style.transform = "translateX(calc(-50vw - 100%))"

        setTimeout(() => {
            popup.style.padding = "0";

            loadingBar.style.height = "0";
            loadingBar.style.overflow = "hidden";

            setTimeout(() => {
                loadingBar.remove();
                mapElm.style.filter = "none";
            }, 500)
        }, 200)

        hideText();
    }

    function syncPositions() {
        const players = Object.values(window.room.players);

        steps.forEach(step => {
            step.xOffset = 0;
            step.players = 0;
            step.playersMax = players.filter(player => player.step == steps.indexOf(step)).length;
        });

        players.forEach(player => {
            const step = steps[player.step];
            const playerElm = player.mapElm;
            const playerWidth = playerElm.offsetWidth;

            const [x, y] = [
                step.x,
                step.y
            ]

            step.players++;
            step.xOffset += 10; // playerWidth - 20;

            playerElm.style.left = `calc(${x}% + ${step.players == 0 ? 0 : step.xOffset - (step.playersMax * 10 / 2)}px)`;
            playerElm.style.top = `calc(${y}% + ${step.players * 5 - step.playersMax * 5}px)`;
        });
    }

    function movePlayer(player, step) {
        const diff = step - player.step;

        for (let i = 0; i < Math.abs(diff); i++) {
            setTimeout(() => {
                player.step += Math.sign(diff); // MDN docs clutch
                syncPositions();
            }, i * 400)
        }
    }

    window.movePlayer = movePlayer;

    function loadPlayers() {
        const players = Object.values(window.room.players);

        players.forEach(player => {
            const playerElm = document.createElement("player");
            const avatar = document.createElement("img");
            const usernameElm = document.createElement("b");

            const isMe = player.id == window.player.id;

            playerElm.id = player.id;

            avatar.width = avatar.height = "48";
            avatar.src = `assets/avatars/${player.avatar_id}.png`;

            if (isMe) playerElm.style.background = "lightgoldenrodyellow";

            usernameElm.innerText = player.username;

            playerElm.appendChild(avatar);
            playerElm.appendChild(usernameElm);

            playersElm.appendChild(playerElm);

            player.mapElm = playerElm;
        });

        syncPositions();
    }

    async function load() {
        const response = await fetch(map.step_map);
        const json = await response.json();

        const dimensions = json["dimensions"];

        notify("Map", `Loaded <b>${map.name}</b> by <b>${json.author}</b>`, 4000, ["success"])

        room.map.steps = steps = json["steps"].map(step => {
            return {
                x: step.x / dimensions.width * 100,
                y: step.y / dimensions.height * 100
            }
        });

        loadPlayers();

        connection.send("game.ready", "game_wheel")
    }

    async function introduce() {
        return connection.send("game.wheel.ready");

        showText(`Welcome to the ${room.map.name}`);
        await sleep(2000);
        setText("We will spin the wheel to determine the game.");
        await sleep(2000);
        setText("1st place will move 3 steps, 2nd move 2, and 3rd move 1.");
        await sleep(4000);
        hideText();

        notify("Game Wheel", "Please wait, while we prepare the wheel.", 3000);

        connection.send("game.wheel.ready");
    }

    function onGameReady(data) {
        setTimeout(() => {
            onLoad();

            setTimeout(() => {
                introduce();
            }, 1500)
        }, 500)
    }

    load();

    async function onGameWheelReady(games) {
        room.game_index = games[0];
        room.games = games[1];
        pushScreen("game_wheel");
    }

    connection.events.on("game.wheel.ready", onGameWheelReady);
    connection.events.on("game.ready.game_wheel", onGameReady);
</script>

<style>
    .map {
        position: relative;

        width: fit-content;
        height: fit-content;

        transition: 0.75s;
        filter: blur(20px);
    }

    #map-img {
        width: 100%;
        max-height: 100%;
        object-fit: contain;

        user-select: none;
    }

    .players player {
        position: absolute;

        display: flex;
        flex-direction: column;

        align-items: center;

        border: #191919 1px solid;

        background: var(--background);
        border-radius: 4px;
        padding: 3px 10px 5px 10px;

        transform: translate(-50%, -100%);
        transition-duration: 0.5s;
    }

    .players player:hover {
        z-index: 50;
        transform: translate(-45%, -95%);
        scale: 1.1;
    }
</style>